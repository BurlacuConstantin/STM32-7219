#include <stm32f1xx_hal.h>
#include <stm32_hal_legacy.h>
#include <SystemClock.h>
#include <MAX7219.h>
#include <ADC.h>
#include <FFT.h>

//#include <complex.h>

#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
#define bitSet(value, bit) ((value) |= (1UL << (bit)))
#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))

volatile uint8_t disp1ay[98][8] =
{ 
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
	  			// Space - Ascii 32
	{ 0x0, 0x10, 0x10, 0x10, 0x10, 0x0, 0x10, 0x0 },
	  		// !
	{ 0x0, 0x24, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0 },
	  		// ”
	{ 0x0, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x0 },
	  	// #
	{ 0x0, 0x8, 0x3E, 0x28, 0x3E, 0xA, 0x3E, 0x8 },
	  		// $
	{ 0x0, 0x62, 0x64, 0x8, 0x10, 0x26, 0x46, 0x0 },
	  		// %
	{ 0x0, 0x10, 0x28, 0x10, 0x2A, 0x44, 0x3A, 0x0 },
	  	// &
	{ 0x0, 0x8, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0 },
	  			// ‘
	{ 0x0, 0x4, 0x8, 0x8, 0x8, 0x8, 0x4, 0x0 }, 
	 			// (
	{ 0x0, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x0 },
	  	// )
	{ 0x0, 0x0, 0x14, 0x8, 0x3E, 0x8, 0x14, 0x0 },
	  		// *
	{ 0x0, 0x0, 0x8, 0x8, 0x3E, 0x8, 0x8, 0x0 },
	  			// +
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x8, 0x10 }, 
	 			// ,
	{ 0x0, 0x0, 0x0, 0x0, 0x3E, 0x0, 0x0, 0x0 },
	  			// -
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x18, 0x0 },
	  		// .
	{ 0x0, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x0 },
	  		// /
	{ 0x0, 0x3C, 0x46, 0x4A, 0x52, 0x62, 0x3C, 0x0 },
	  	// 0 - Ascii 48
	{ 0x0, 0x30, 0x50, 0x10, 0x10, 0x10, 0x7C, 0x0 },
	  	// 1
	{ 0x0, 0x3C, 0x42, 0x2, 0x3C, 0x40, 0x7E, 0x0 }, 
	 		// 2
	{ 0x0, 0x3C, 0x42, 0xC, 0x2, 0x42, 0x3C, 0x0 },
	  		// 3
	{ 0x0, 0x8, 0x18, 0x28, 0x48, 0x7E, 0x8, 0x0 },
	  		// 4
	{ 0x0, 0x7E, 0x40, 0x7C, 0x2, 0x42, 0x3C, 0x0 }, 
	 		// 5
	{ 0x0, 0x3C, 0x40, 0x7C, 0x42, 0x42, 0x3C, 0x0 },
	  	// 6
	{ 0x0, 0x7E, 0x2, 0x4, 0x8, 0x10, 0x10, 0x0 }, 
	 		// 7
	{ 0x0, 0x3C, 0x42, 0x3C, 0x42, 0x42, 0x3C, 0x0 },
	  	// 8
	{ 0x0, 0x3C, 0x42, 0x42, 0x3E, 0x2, 0x3C, 0x0 },
	  		// 9
	{ 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x0 },
	  		// : - Ascii 58
	{ 0x0, 0x0, 0x10, 0x0, 0x0, 0x10, 0x10, 0x20 }, 
	 		//
	{ 0x0, 0x0, 0x4, 0x8, 0x10, 0x8, 0x4, 0x0 },
	  			// <
	{ 0x0, 0x0, 0x0, 0x3E, 0x0, 0x3E, 0x0, 0x0 },
	  		// =
	{ 0x0, 0x0, 0x10, 0x8, 0x4, 0x8, 0x10, 0x0 },
	  		// >
	{ 0x0, 0x3C, 0x42, 0x4, 0x8, 0x0, 0x8, 0x0 },
	  		// ?
	{ 0x0, 0x3C, 0x4A, 0x56, 0x5E, 0x40, 0x3C, 0x0 },
	  	// @
	{ 0x0, 0x3C, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x0 }, // 33
	 	// A - Ascii 65
	{ 0x0, 0x7C, 0x42, 0x7C, 0x42, 0x42, 0x7C, 0x0 }, // 34
	  	// B
	{ 0x0, 0x3C, 0x42, 0x40, 0x40, 0x42, 0x3C, 0x0 }, // 35
	  	// C
	{ 0x0, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x0 }, // 36
	  	// D
	{ 0x0, 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x7E, 0x0 }, // 37
	  	// E
	{ 0x0, 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x0 }, // 38
	  	// F
	{ 0x0, 0x3C, 0x42, 0x40, 0x4E, 0x42, 0x3C, 0x0 }, // 39
	  	// G
	{ 0x0, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x0 }, // 40
	  	// H
	{ 0x0, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x0 },
	  	// I
	{ 0x0, 0x2, 0x2, 0x2, 0x2, 0x42, 0x3C, 0x0 },
	  		// J
	{ 0x0, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x0 }, 
	 	// K
	{ 0x0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x0 }, // 44
	  	// L
	{ 0x0, 0x42, 0x66, 0x5A, 0x42, 0x42, 0x42, 0x0 },
	  	// M
	{ 0x0, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x0 }, 
	 	// N
	{ 0x0, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x0 },
	  	// O
	{ 0x0, 0x7C, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x0 },
	  	// P
	{ 0x0, 0x3C, 0x42, 0x42, 0x52, 0x4A, 0x3C, 0x0 },
	  	// Q
	{ 0x0, 0x7C, 0x42, 0x42, 0x7C, 0x44, 0x42, 0x0 }, 
	 	// R
	{ 0x0, 0x3C, 0x40, 0x3C, 0x2, 0x42, 0x3C, 0x0 }, // 51
	  		// S
	{ 0x0, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0 }, // 52
	  	// T
	{ 0x0, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x0 }, // 53
	  	// U
	{ 0x0, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x0 },
	  	// V
	{ 0x0, 0x42, 0x42, 0x42, 0x42, 0x5A, 0x24, 0x0 },
	  	// W
	{ 0x0, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x0 },
	  	// X
	{ 0x0, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x0 },
	  	// Y
	{ 0x0, 0x7E, 0x4, 0x8, 0x10, 0x20, 0x7E, 0x0 }, // 58
	  		// Z - Ascii 90
	{ 0x0, 0xE, 0x8, 0x8, 0x8, 0x8, 0xE, 0x0 },
	  		    // {
	{ 0x0, 0x0, 0x40, 0x20, 0x10, 0x8, 0x4, 0x0 },
	  		// \
	{ 0x0, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x0 },
	  	// }
	{ 0x0, 0x10, 0x38, 0x54, 0x10, 0x10, 0x10, 0x0 },
	  	// ^
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xFF },
	  		    // _
	{ 0x0, 0x1C, 0x22, 0x78, 0x20, 0x20, 0x7E, 0x0 },
	  	// £
	{ 0x0, 0x0, 0x38, 0x4, 0x3C, 0x44, 0x3C, 0x0 }, 
	 		// a - Ascii 97
	{ 0x0, 0x40, 0x40, 0x78, 0x44, 0x44, 0x78, 0x0 },
	  	// b
	{ 0x0, 0x0, 0x38, 0x40, 0x40, 0x40, 0x38, 0x0 },
	  		// c
	{ 0x0, 0x4, 0x4, 0x3C, 0x44, 0x44, 0x3C, 0x0 },
	  		// d
	{ 0x0, 0x0, 0x38, 0x44, 0x78, 0x40, 0x3C, 0x0 }, 
	 		// e
	{ 0x0, 0x30, 0x40, 0x60, 0x40, 0x40, 0x40, 0x0 },
	  	// f
	{ 0x0, 0x3C, 0x44, 0x44, 0x3C, 0x4, 0x38, 0x0 }, 
	 		// g
	{ 0x0, 0x40, 0x40, 0x40, 0x78, 0x44, 0x44, 0x0 }, 
	 	// h
	{ 0x0, 0x20, 0x0, 0x60, 0x20, 0x20, 0x70, 0x0 },
	  		// i
	{ 0x0, 0x8, 0x0, 0x8, 0x8, 0x48, 0x30, 0x0 },
	  		// j
	{ 0x0, 0x40, 0x50, 0x60, 0x60, 0x50, 0x48, 0x0 }, 
	 	// k
	{ 0x0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x30, 0x0 },
	  	// l
	{ 0x0, 0x0, 0x68, 0x54, 0x54, 0x54, 0x54, 0x0 },
	  		// m
	{ 0x0, 0x0, 0x78, 0x44, 0x44, 0x44, 0x44, 0x0 }, 
	     	// n
	{ 0x0, 0x0, 0x38, 0x44, 0x44, 0x44, 0x38, 0x0 },
	  		// o
	{ 0x0, 0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x0 },
	  	// p
	{ 0x0, 0x3C, 0x44, 0x44, 0x3C, 0x4, 0x6, 0x0 },
	  		// q
	{ 0x0, 0x0, 0x1C, 0x20, 0x20, 0x20, 0x20, 0x0 },
	  	   	// r
	{ 0x0, 0x0, 0x38, 0x40, 0x38, 0x4, 0x78, 0x0 },
	  		// s
	{ 0x0, 0x20, 0x70, 0x20, 0x20, 0x20, 0x18, 0x0 }, 
	 	// t
	{ 0x0, 0x0, 0x44, 0x44, 0x44, 0x44, 0x38, 0x0 },
	  		// u
	{ 0x0, 0x0, 0x44, 0x44, 0x28, 0x28, 0x10, 0x0 },
	  		// v
	{ 0x0, 0x0, 0x44, 0x54, 0x54, 0x54, 0x28, 0x0 },
	  		// w
	{ 0x0, 0x0, 0x44, 0x28, 0x10, 0x28, 0x44, 0x0 },
	  		// x
	{ 0x0, 0x0, 0x44, 0x44, 0x3C, 0x4, 0x38, 0x0 },
	  		// y
	{ 0x0, 0x0, 0x7C, 0x8, 0x10, 0x20, 0x7C, 0x0 },
	  		// z - Ascii 122
	{ 0x0, 0xE, 0x8, 0x30, 0x8, 0x8, 0xE, 0x0 },
	  			// {
	{ 0x0, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x0 },
	  			// |
	{ 0x0, 0x70, 0x10, 0xC, 0x10, 0x10, 0x70, 0x0 },
	  		// }
	{ 0x0, 0x14, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0 }, 
	 		// ~
	{ 0x3C, 0x42, 0x99, 0xA1, 0xA1, 0x99, 0x42, 0x3C },
	  	// © - Ascii 127
	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
	  	// Block Graphic 1
};


#ifdef __cplusplus
extern "C" 
#endif

#define delayUS_ASM(us) do {\
	asm volatile (	"MOV R0,%[loops]\n\t"\
			"1: \n\t"\
			"SUB R0, #1\n\t"\
			"CMP R0, #0\n\t"\
			"BNE 1b \n\t" : : [loops] "r" (15*us) : "memory"\
		      );\
} while(0)

/* For timer SysClck */
void SysTick_Handler(void)
{
	HAL_IncTick();
	HAL_SYSTICK_IRQHandler();
}
/* ----------------- */

TIM_HandleTypeDef htim2;

SystemClock clk = SystemClock();  // object
MAX7219 max7219 = MAX7219(4);  // object
ADC adc = ADC();
FFT myFFT = FFT();

void MX_TIM2_Init(void);
void InitializeTimer(TIM_HandleTypeDef* timer);

void ScrollBytes(uint8_t addr, char array_num, uint16_t delay_ms, uint8_t l_to_r);

void MX_TIM2_Init(void)
{

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
	
	// 	Tim Freq = (periferical clock) 72 MHZ / ((1 + 1) * (749 + 1)) = 48khz
	htim2.Instance = TIM2;
	htim2.Init.Prescaler = 1;  // 35999
	htim2.Init.Period =	719;	// 1
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	HAL_TIM_Base_Init(&htim2);

	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig);

	sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;  // reset or update , update is more ok = overflow / downflow
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
	
}

void InitializeTimer(TIM_HandleTypeDef* timer)
{
	__TIM2_CLK_ENABLE();  // enable peripheral clock for timer
	HAL_NVIC_SetPriority(TIM2_IRQn, 1, 0);    // setup priority interrupt
	HAL_NVIC_EnableIRQ(TIM2_IRQn);   // enable interrupt request
	
	MX_TIM2_Init();  // initialize timer values
	HAL_TIM_Base_Start_IT(timer);  // start the timer 
}


void ScrollBytes(uint8_t addr, char array_num, uint16_t delay_ms, uint8_t l_to_r, bool onlyOne = false)
{
	uint8_t result = array_num - 32;
	
	switch (l_to_r)
	{
	case 0:
		{
			for (int k1 = 0; k1 < 8; k1++)
			{
				for (int i = 1; i <= 8; i++)
				{
					if (onlyOne == false)
						max7219.SendToOne(addr, i, (disp1ay[result][i - 1]));
					else
						max7219.SendToAll(i, (disp1ay[result][i - 1]));
				}
				HAL_Delay(delay_ms);
			}
			
			break;
		}
	case 1:
		{
			for (int k1 = 0; k1 < 8; k1++)
			{
				for (int i = 1; i <= 8; i++)
				{
					if (onlyOne == false)
						max7219.SendToOne(addr, i, (disp1ay[result][i - 1]) >> k1);
					else
						max7219.SendToAll(i, (disp1ay[result][i - 1]) >> k1);
				}
				HAL_Delay(delay_ms);
			}
			
			break;
		}
	case 2:
		{
			for (int k1 = 0; k1 < 8; k1++)
			{
				for (int i = 1; i <= 8; i++)
				{
					if (onlyOne == false)
						max7219.SendToOne(addr, i, (disp1ay[result][i - 1]) << k1);
					else
						max7219.SendToAll(i, (disp1ay[result][i - 1]) << k1);
				}
				HAL_Delay(delay_ms);
			}
			
			break;
		}
	}
}

#define MAX_SAMPLES 32

uint16_t adc_values[MAX_SAMPLES];
float vReal[MAX_SAMPLES];
float vImag[MAX_SAMPLES];
float vMag[MAX_SAMPLES];
uint16_t samples_counter = 0;
bool done_sampling = false;
bool can_update = false;

int main(void)
{
	HAL_Init();
	
	clk.SetupClk();   // setup the clock
	max7219.Begin();   // setup max device
	max7219.SetIntensityLevel(2);    // intensity of leds ( current limitation )
	
	adc.ADC_Begin(GPIO_PIN_0, ADC_CHANNEL_0, ADC_SAMPLETIME_1CYCLE_5); // setup the adc 1 
	MX_TIM2_Init();
	InitializeTimer(&htim2);
	GPIO_InitTypeDef GPIO_InitStruct1 = { 0 };

	__HAL_RCC_GPIOC_CLK_ENABLE();
	
	GPIO_InitStruct1.Pin = GPIO_PIN_13;
	GPIO_InitStruct1.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct1.Pull = GPIO_NOPULL;
	GPIO_InitStruct1.Speed = GPIO_SPEED_FREQ_MEDIUM;
	HAL_GPIO_Init(GPIOC, & GPIO_InitStruct1);
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);

	uint8_t data = 0;
	float min_adc = 0, max_adc = 0;
	
	for (;;)
	{
		// Waiting for samples
		//while (done_sampling != true) ;
//		for (int i = 0; i < MAX_SAMPLES; i++)
//		{
//			vReal[i] = adc.ADC_ReadConversion();
//			vImag[i] = 0;
//			delayUS_ASM(50);
//			
//			if (vReal[i] > max_adc) // find the biggest from adc conversions
//			{
//				max_adc = vReal[i];
//			}
//			else if(vReal[i] < min_adc) // fiind the lowest 
//			{
//				min_adc = vReal[i];
//			}
//		}
		
		while (done_sampling != true) ;
		
		// Register the adc values 
		for (int i = 0; i < MAX_SAMPLES; i++)
		{
			vReal[i] = adc_values[i];
			vImag[i] = 0;
			
			if (vReal[i] > max_adc) // find the biggest from adc conversions
			{
				max_adc = vReal[i];
			}
			else if(vReal[i] < min_adc) // fiind the lowest 
			{
				min_adc = vReal[i];
			}
		}
		
		// Windowing the data from adc to avoid as posible the noise
//		for (int i = 0; i < (MAX_SAMPLES >> 1); i++)
//		{
//			float samplesMinusOne = MAX_SAMPLES - 1.0;
//			float indexMinusOne = (float)i;
//			float ratio = (indexMinusOne / samplesMinusOne);
//			float weightFactor = 0.54 - (0.46 * cos((2 * PI) * ratio));
//			
//			vReal[i] *= weightFactor;
//			vReal[MAX_SAMPLES - (i + 1)] *= weightFactor;
//		}
		
		myFFT.Fft_transformRadix2(vReal, vImag, MAX_SAMPLES);
		//myFFT.Fft_transformRadix4(vReal, vImag, MAX_SAMPLES, 3);
		//myFFT.mag_to_bufD(vMag, vReal, vImag, MAX_SAMPLES, min_adc, max_adc);
		//myFFT.fft(vReal, vImag, MAX_SAMPLES);
		myFFT.mag_to_buf(vMag, vReal, vImag, MAX_SAMPLES, min_adc, max_adc);
		
		done_sampling = false;
		
		
		for (int j = 0; j < 8; j++)
		{
			data = vMag[j];
			for (int i = 0; i <= data; i++)
			{
				max7219.SetLed(1, i, j, true);
				//delayUS_ASM(50);
			}
		}
		for (int j = 0; j < 7; j++)
		{
			data = vMag[j + 8];
			for (int i = 0; i <= data; i++)
			{
				max7219.SetLed(2, i, j, true);
				//delayUS_ASM(50);
			}
		}
		
		
		
		
//		data = vMag[0];
//		for (int i = 0; i <= data; i++)
//		{
//			max7219.SetLed(0, i, 0, true);
//			max7219.SetLed(0, i, 1, true);
//		}
//		
//		data = vMag[1];
//		for (int i = 0; i <= data; i++)
//		{
//			max7219.SetLed(0, i, 3, true);
//			max7219.SetLed(0, i, 4, true);
//		}
//		
//		data = vMag[2];
//		for (int i = 0; i <= data; i++)
//		{
//			max7219.SetLed(0, i, 6, true);
//			max7219.SetLed(0, i, 7, true);
//		}
//		
//		data = vMag[3];
//		for (int i = 0; i <= data; i++)
//		{
//			max7219.SetLed(1, i, 1, true);
//			max7219.SetLed(1, i, 2, true);
//		}
//		
//		data = vMag[4];
//		for (int i = 0; i <= data; i++)
//		{
//			max7219.SetLed(1, i, 4, true);
//			max7219.SetLed(1, i, 5, true);
//		}
//		
//		data = vMag[5];
//		for (int i = 0; i <= data; i++)
//		{
//			max7219.SetLed(1, i, 7, true);
//			max7219.SetLed(2, i, 0, true);
//		}
//		
//		data = vMag[6];
//		for (int i = 0; i <= data; i++)
//		{
//			max7219.SetLed(2, i, 2, true);
//			max7219.SetLed(2, i, 3, true);
//		}
//		
//		data = vMag[7];
//		for (int i = 0; i <= data; i++)
//		{
//			max7219.SetLed(2, i, 5, true);
//			max7219.SetLed(2, i, 6, true);
//		}
//		
//		data = vMag[8];
//		for (int i = 0; i <= data; i++)
//		{
//			max7219.SetLed(3, i, 0, true);
//			max7219.SetLed(3, i, 1, true);
//		}
//		
	} 
}


extern "C" void TIM2_IRQHandler(void) 
{
	if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET)
	{
		if (__HAL_TIM_GET_IT_SOURCE(&htim2, TIM_IT_UPDATE) != RESET)
		{
			__HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);
			
			if (samples_counter <= MAX_SAMPLES && done_sampling != true)
			{
				adc_values[samples_counter] = adc.ADC_ReadConversion();
				samples_counter++;
				
				//HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
			}
			else if (samples_counter > MAX_SAMPLES)
			{
				samples_counter = 0;
				done_sampling = true;
			}
			
		}
	}
}
		



/* EFECTE DE TRANZITIE LEFT TO RIGHT */
/*
for (int j = 16; j < 26; j++)
{
	for (int k = 0; k < max7219.getMaxDevices(); k++)
	{
		for (int i = 1; i <= 8; i++)
		{
			max7219.SendToOne(k, i, (disp1ay[j][i - 1]));
		}
		HAL_Delay(4);
	}
	HAL_Delay(10);

}
max7219.ClearMatrix();
		
for (int j = 16; j < 26; j++)
{
	for (int i = 1; i <= 8; i++)
	{
		for (uint8_t k = 0; k < max7219.getMaxDevices(); k++)
		{
			max7219.SendToOne(k, i, (disp1ay[j][i - 1]));
			HAL_Delay(2);
		}
	}
	HAL_Delay(10);
}
max7219.ClearMatrix();
*/

/* ALT EFFECT DE TRANZITIE
for (int j = 16; j < 26; j++)
		{
			for (int k = 0; k < 8; k++)
			{
				for (int i = 1; i <= 8; i++)
				{
					max7219.SendToOne(0, i, (disp1ay[j][i - 1]) >> k);
					
				}
				for (int i = 1; i <= 8; i++)
				{
					max7219.SendToOne(1, i, (disp1ay[j][i - 1]) << k);
				}
			}
			HAL_Delay(3);
		}
*/
